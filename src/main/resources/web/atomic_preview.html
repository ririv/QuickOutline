<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Atomic Preview</title>
    <style>
        /* 1. 背景：深灰色的阅读器风格 */
        body {
            background-color: #525659;
            margin: 0;
            padding: 30px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: scroll; /* 保持滚动条 */
        }

        /* 2. 纸张容器：模拟 A4 纸 */
        .page-sheet {
            background-color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            position: relative; /* 作为原子块绝对定位的基准 */
            overflow: hidden;   /* 防止内容溢出 */

            /* A4 尺寸 (595pt x 842pt) */
            width: 595pt;
            height: 842pt;
            transition: none; /* 禁止动画，为了性能 */
        }

        /* 3. 原子块：绝对定位的积木 */
        .atomic-block {
            position: absolute;
            left: 0;
            width: 100%; /* 宽度占满页面 */
            /* 调试用：可以看到每个块的边界 */
            /* border: 1px dashed rgba(255, 0, 0, 0.2); */
        }

        /* SVG 样式：让内容自适应块大小 */
        .atomic-block svg {
            display: block;
            width: 100%;
            height: auto;
            overflow: visible;
        }
    </style>
</head>
<body>
<div id="document-root"></div>

<script>
    // 简单的日志桥接
    function log(msg) { if(console) console.log("[AtomicJS] " + msg); }

    /**
     * 渲染原子块列表
     * @param jsonString JSON 字符串: List<DocumentBlock>
     */
    window.renderAtomicBlocks = function(jsonString) {
        let blocks;
        try {
            blocks = JSON.parse(jsonString);
        } catch (e) {
            console.error("JSON parse failed", e);
            return;
        }

        if (!blocks || blocks.length === 0) return;

        const root = document.getElementById('document-root');
        if (!root) return;

        // 1. 计算总页数
        let maxPage = 0;
        for (let b of blocks) {
            if (b.pageNumber > maxPage) maxPage = b.pageNumber;
        }

        // 2. 增删页面容器 (Virtual Pagination)
        // 增加缺少的页
        while (root.children.length < maxPage) {
            let pageNum = root.children.length + 1;
            let pageDiv = document.createElement('div');
            pageDiv.className = 'page-sheet';
            pageDiv.id = 'page-' + pageNum;
            root.appendChild(pageDiv);
        }
        // 删除多余的页
        while (root.children.length > maxPage) {
            root.removeChild(root.lastChild);
        }

        // 3. 渲染积木 (增量更新 DOM)
        // 为了极致性能，我们可以对比 ID，这里先做全量清空再插入，
        // 因为 innerHTML 替换整个页面内容通常比 JS 逐个对比 DOM 还要快 (在几百个块以内)。

        // 这种策略叫 "Page-Level Rehydration" (页面级注水)
        // 我们只清空内容有变化的页面的 HTML

        // 既然这是原子块列表，我们需要按页分组
        let pagesContent = new Map(); // Key: pageNum, Value: htmlString buffer

        for (let block of blocks) {
            let p = block.pageNumber;
            if (!pagesContent.has(p)) pagesContent.set(p, "");

            // 拼接 HTML: <div class="atomic-block" style="top: ..."> <svg>...</svg> </div>
            let blockHtml = `<div class="atomic-block" style="top: ${block.topPt}pt; height: ${block.heightPt}pt;">${block.svgContent}</div>`;
            pagesContent.set(p, pagesContent.get(p) + blockHtml);
        }

        // 批量更新 DOM
        for (let i = 1; i <= maxPage; i++) {
            let pageDiv = document.getElementById('page-' + i);
            let newHtml = pagesContent.get(i) || "";

            // 【核心优化】只有当 HTML 字符串不同时才写入 DOM
            // 这防止了无意义的重绘 (Repaint)
            // 我们利用了一个自定义属性 data-hash 来存储上次的内容指纹，或者直接比对 innerHTML 长度粗略判断
            // 这里直接比对 innerHTML 可能会慢，但比重绘快。

            // 简单粗暴版：直接覆盖。浏览器引擎现在很聪明，会处理得很快。
            if (pageDiv.innerHTML !== newHtml) {
                pageDiv.innerHTML = newHtml;
            }
        }
    };
</script>
</body>
</html>