---
date: 2026-01-19
title: 拖拽功能 UX 优化与算法设计
tags: [frontend, drag-drop, ux, algorithm]
---

# 拖拽功能 UX 优化与算法设计

本文档记录了对 QuickOutline 书签树拖拽功能的 UX 优化过程，重点阐述了对齐策略调整和层级判定算法的稳定性改进。

## 1. 视觉对齐优化

### 问题背景
原本的拖拽指示线（Gap Line）起点是基于节点的物理边界（包含图标区域）计算的。导致视觉上指示线起点位于节点最左侧，与节点标题文字存在约 36px 的错位，层级感不强且不美观。

### 解决方案
将指示线的对齐基准从“节点容器边缘”调整为“节点标题文字起始点”。

#### 关键常量调整
在 `src/lib/drag-drop/treeLayout.ts` 中引入了偏移量常量：

```typescript
export const TREE_INDENT = 20;       // 层级缩进宽度（保持紧凑）
export const TREE_BASE_PADDING = 4;  // 容器基础内边距
export const NODE_CONTENT_OFFSET = 36; // 偏移量：拖拽手柄(14+2) + 展开按钮(20)
```

#### 逻辑分离
为了代码的可维护性，将节点行和指示线的计算逻辑分离：

1.  **节点内容位置** (`getNodePadding`)：
    *   计算公式：`(Level - 1) * 缩进 + 基础内边距`
    *   用途：控制整行内容（图标+文字）的缩进。

2.  **指示线位置** (`getGapIndent`)：
    *   计算公式：`(Level - 1) * 缩进 + 基础内边距 + 内容偏移量`
    *   用途：控制拖拽指示线的起点，使其精确对齐标题文字。

3.  **鼠标反算层级** (`calculateLevelFromX`)：
    *   引入了与 `getGapIndent` 互逆的计算逻辑，确保鼠标的触发区域与视觉上的指示线位置严格对应。

## 2. 交互稳定性优化（Gap Normalization）

### 问题背景
在早期的实现中，在两个节点之间的缝隙（Gap）拖拽时，允许用户通过水平移动鼠标来任意改变层级（成为子节点或兄弟节点）。
**痛点**：用户只想做兄弟节点插入时，鼠标稍有抖动就会变成子节点插入，导致横线左右乱跳，操作体验极差。

### 核心策略：向上归属原则

我们采用了**“向上归属（Previous Node Affinity）”**策略，即将节点间的缝隙逻辑上归属于**上一个节点（RefNode）的 `After` 区域**。

#### 1. 为什么采用“向上归属”？
*   **稳定性**：无论鼠标在缝隙的偏上还是偏下位置，只要上一个节点不变，指示线的基准层级就保持不变，消除了垂直移动时的横向跳变。
*   **统一性**：将“节点 B 的上半部分”归一化为“节点 A 的下半部分”，简化了状态判定。

#### 2. 替代方案分析（为什么不采用“优先归属子节点”？）
曾考虑将缝隙优先归属给下方节点（Next Node Affinity），但分析后发现会导致**跳变（Jumping）**问题：
*   当鼠标从父节点下半部分（Level 1）滑到子节点上半部分（Level 2）时，指示线会突然发生位移。
*   且列表最后一个节点的下方没有“Next Node”，处理起来会产生逻辑死角。

目前的“向上归属 + 上下文感知”方案是在稳定性（默认不跳）和灵活性（允许特定场景缩进）之间找到的最佳平衡点。

#### 3. 绝对顶部特例 (`refNode === null`)
当鼠标处于**整个树的第一个节点**上半部分时，由于上方没有节点，`refNode` 被判定为 `null`。
*   **行为**：进入独立分支，无条件执行 `before` 插入。
*   **局限**：该逻辑无法处理子列表顶部，因为子列表上方必然存在一个父节点作为 `refNode`。

### 核心策略：层级锁定

#### 1. 规则 1：Gap 模式默认禁止缩进
在普通缝隙（两个兄弟节点之间）中，**禁止** `targetLevel` 大于 `refNode.level`。
*   **鼠标右拉**：横线保持不动（锁死在 `refNode` 的层级）。
*   **鼠标左拉**：允许向左移动（Outdent），成为祖先节点的兄弟。
*   **效果**：彻底消除了“想放下面却不小心变成子节点”的误操作。如果用户想把节点变成子节点，应直接拖入节点内部（Inside 模式）。

#### 2. 规则 2：父子缝隙的特殊豁免
**特例**：当缝隙位于“已展开的父节点”和“第一个子节点”之间时。
*   **原因**：受“向上归属”原则影响，此处被视为父节点的 `After` 区。若执行规则 1，将导致无法在子列表顶部插入第一个子节点。
*   **修正逻辑**：检测上下文，如果 `nextNode` 存在且层级比 `refNode` 深（说明 `nextNode` 是 `refNode` 的子节点），则**豁免**规则 1 的限制，允许 `targetLevel` 达到 `nextNode.level`。

```typescript
// 逻辑实现片段
let maxLevel = refNode.level;
if (refNode && nextNode && nextNode.level > refNode.level) {
    maxLevel = nextNode.level; // 允许向右缩进以对齐子节点
}
```