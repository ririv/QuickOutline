

# PDF 转 SVG 增量预览方案总结

## 1. 项目背景与核心挑战

### 1.1. 性能痛点
我们的目标是实现 **文字可选中** 的同时，达到 **无闪烁、无卡顿** 的预览体验（类似 Typst）。
之前的方案 
- PDF.js 总是重新加载
- Image，也可以做到像svg那样无闪烁，但文字不可选中、生成速度慢


### 1.2. 核心技术难题
要实现高性能预览，我们必须将 PDF 矢量图转换为 SVG。但在 Java 端，我们面临两个根本矛盾：
1.  **渲染冲突**：PDFBox 的原生渲染器 (`PDFRenderer`) 为了视觉绝对准确，将文字转为 **矢量路径 (`<path>`)**。这导致 SVG DOM 节点数量爆炸，造成 WebView 滚动卡顿。
2.  **坐标系冲突**：PDF (左下原点，Y向上) 与 SVG (左上原点，Y向下) 的坐标系不同，造成<text>颠倒。

---

## 2. 架构奠基与关键修复

我们选定 **“全量 PDF 生成 + 页面级 SVG Diff”** 为最终架构。

### 2.1. 字形性能优化
直接使用svg2pdf的方案是行不通的，因为大量渲染path会导致卡顿

为了解决卡顿问题，有两种方案
-  `<path>` 替换为廉价的 `<text>` 标签。
- 字形缓存 (Glyph Caching)：将相同的字形只渲染一次，后续使用 `<use>` 引用。

### 2.2. 功能修复：选中与对齐的统一

| 问题 | 原因 | 解决方案 |
| :--- | :--- | :--- |
| **公式图形错误** | 坐标系翻转导致 MathJax 路径的 **Winding Rule** 逻辑失效。 | 放弃复杂的全局翻转，使用 **Batik 代理**，让它自动处理复杂的贝塞尔曲线和填充逻辑。 |
| **选中不连续** | `showGlyph` 默认一个字一个 `<text>`，且浏览器空格宽度不匹配。 | 引入 **文本缓冲 (Text Buffer)**。代码在检测到换行或明显间距跳跃时，才 `flushBuffer`，将整个单词或短语合并为一个 `<text>` 标签。 |
| **位置漂移** | 系统字体 (`SansSerif`) 宽度与 PDF 字体宽度不一致，导致累积误差。 | **字体拉伸** (Stretch/ScaleX)。计算 PDF 理论宽度与 AWT 字体实际宽度的比值，然后用 `AffineTransform` 对文本进行微小拉伸，确保透明文字的宽度与底层图形完美匹配。 |


### 2.3 坐标系导致的文字倒立

是的，我们为了解决 PDF 的 Y 轴方向（由下往上）与 SVG 的 Y 轴方向（由上往下）的根本冲突，采用了两种不同的策略：

#### 翻转 (Global Transform/Flipping) 策略

* **机制**：在 SVG 的最外层内容组上应用 **`scale(1, -1)`** 变换，强制 SVG 坐标系与 PDF 坐标系（Y轴向上）对齐。
* **副作用**：导致文字倒立，必须再进行一次局部翻转（“二次翻转”）来矫正。这种复杂的变换链会导致浏览器在计算**鼠标选区**时出现错误和错位。

####  坐标 (Manual Calculation/Reset) 策略

* **机制**：**放弃**全局翻转。在 Java 代码中，手动将每一个 PDF 坐标点 $Y_{\text{PDF}}$ 转换成 SVG 坐标点 $Y_{\text{SVG}}$。
    * **公式**：$Y_{\text{SVG}} = \text{PageHeight} - Y_{\text{PDF}}$。
* **优点**：这是最终的解决方案，因为它提供了浏览器最喜欢的 **“干净的、轴对齐的”** 坐标，从而实现了**完美无错的文字选中体验**。

---


## 3. 页面级 Diff 缓存

缓存目标：存储每一页的最终 SVG 字符串 (pageCache<Integer, String>)。

工作方式：当用户输入时，系统全量生成 PDF，但只将新生成的 SVG 字符串与缓存中的旧字符串进行对比（String.equals(old, new)）。

结果：如果发现内容相同（例如，用户只修改了第 1 页的逗号，但第 2 页内容没变），系统会 阻止 第 2 页的 SVG 传输到前端，从而大幅减少 Socket 传输量和前端 DOM 重绘的开销。

---

我理解了，非常感谢你的指正。这是我对架构的误判，将 **传输层优化（Diff）** 与 **渲染性能优化（Glyph Caching）** 混为一谈。

在 **Typst 风格** 的设计中，**Glyph Caching** 本身就是解决性能瓶颈的内部机制。我们将重新定义方案二，专注于 **图元复用** 的概念。

-----

## 4\. 最终选定的两种方案对比（详述）

### 4.1. 方案一：纯文本替换 (Replacement) [极致性能与轻量 DOM]

该方案旨在解决 WebView 滚动卡顿问题，通过移除文字的矢量轮廓（Paths）来最大化性能。

| 维度 | 技术实现细节 | 效果保证 |
| :--- | :--- | :--- |
| **视觉层** | **只画 `<text>`**：不绘制文字的矢量轮廓，直接画可见 `<text>`。 | **性能之王**：DOM 节点数骤减，滚动性能极佳。 |
| **交互层** | **单层即交互**：可见的 `<text>` 标签同时负责显示和选中。 | 选中体验流畅。 |
| **对齐机制** | **宽度拉伸 (ScaleX)**：计算 PDF 理论字宽与系统字体实际宽度的比值，然后对 `<text>` 进行 **强制拉伸/压缩** 对齐。 | 解决了系统字体与 PDF 字体宽度不一致的问题，确保排版对齐。 |

-----

### 4.2. 方案二：视觉层 + 交互层 (Hybrid Overlay) [绝对保真与图元复用]

该方案旨在保证 **像素级的视觉准确性**，同时利用 **SVG `<defs>`** 实现高性能渲染。

| 维度 | 技术实现细节 | 效果保证 |
| :--- | :--- | :--- |
| **视觉层 (底层)** | **Glyph Caching (\<defs\>/\<use\>)**：提取 PDF 字体轮廓，存储在 `<defs>` 中，正文通过 `<use>` 引用。 | **性能优化**：DOM 节点数量最小化，GPU 渲染效率极高。 **视觉保真**：完美利用 PDFBox 路径，公式绝对无损。 |
| **交互层 (顶层)** | 绘制 **完全透明 (`Alpha=0`)** 的 `<text>` 标签，完美覆盖在 `<use>` 图元上。 | 提供了鼠标选区的感应支持。 |
| **字形缓存机制** | **图元级复用**：扫描每一页的文字，如果该字形 (Font + Code) 已被定义在 `<defs>` 中，则不再生成新的路径数据。 | **核心特性**：这是 Typst 架构的核心性能来源，能保证 SVG 文件结构轻量，避免了 DOM 节点数量爆炸的问题。 |
| **对齐机制** | **原始坐标**：透明文本直接使用 `textRenderingMatrix` 的坐标定位。 | 保证了透明层与 Path 层在物理坐标上的完美重合。 |


这是一份深度融合了**技术架构**与**核心原理（Path vs Text）**的完整总结文档。

---

## 5. PDF 转 SVG 核心方案实现详解

### 5.1 核心目标：从“画图”到“写字”的质变
本方案的核心意义在于：**强制将 PDF 底层的“图形绘制指令”转化为 SVG 的“文本指令”**。

在**绝大多数情况**下，我们生成的 SVG 包含的是真正的 `<text>` 标签，而非矢量路径 `<path>`。这决定了最终产出的 SVG 是否具有 Web 交互性。

#### 核心差异对比

| 特性 | 默认 PDFBox / 普通转换器 | 本方案 (`TextReplacementPageDrawer`) |
| :--- | :--- | :--- |
| **渲染行为** | 读取字体轮廓（贝塞尔曲线），调用 `fillPath` 绘制 | 拦截字符 Unicode，调用 `drawString` 绘制 |
| **SVG 产物** | `<path d="M10 10 L20 20 ... Z" />` | `<text x="10" y="10">A</text>` |
| **本质属性** | **一堆无意义的图形** | **真正的可读文本** |
| **交互能力** | ❌ 不可选中、不可复制、不可搜索 | ✅ **可选中、可复制、可翻译** |
| **文件体积** | 大（需记录复杂的曲线坐标数据） | 小（仅记录字符内容和字体引用） |
| **视觉效果** | 绝对完美（几何绘制） | 极高还原（依赖嵌入字体 @font-face） |

### 5.2 关键实现机制：TextReplacementPageDrawer
这是系统的“心脏”，采用 **“中间人拦截” (Interception)** 模式。通过继承 `PageDrawer`，在 PDFBox 解析指令和 Batik 生成 SVG 之间建立了一个智能过滤层。

#### 1. 智能拦截与转化 (Smart Interception)
这是实现“Path 转 Text”的关键步骤：
* **拦截 (`showGlyph`)**：当 PDFBox 解析到一个字符（如 "A"）时，本方案会拦截默认的绘制行为。
* **重组**：不直接调用父类的绘制方法（因为那会画 Path），而是将字符存入 `textBuffer` 缓冲区。
* **输出**：在合适的时机（如单词结束），调用 Java AWT 标准 API `g2d.drawString(buffer, ...)`。Batik 库在接收到此指令时，会自动将其翻译为 SVG 的 `<text>` 标签。

#### 2. 智能聚合与断词 (Text Aggregation)
为了避免生成“破碎”的 SVG（即每个字母对应一个标签），系统实现了类似“贪吃蛇”的缓冲机制：
* **缓冲逻辑**：将连续的字符存入缓冲区，而非立即上屏。
* **断词触发 (Flush)**：仅在以下情况触发 `<text>` 标签生成：
  * **遇到空格**：空格不被绘制，而是作为天然的词间距处理。
  * **格式变更**：字体、字号或颜色发生变化。
  * **布局跳变**：Y 轴坐标变化（换行）或 X 轴出现非自然间距。

#### 3. 防御性回退策略 (The Fallback Exception)
方案采用了 **“能转文字就转文字，转不了才转路径”** 的混合策略：
* **普通文字**（中文/英文/数字）：提取 Unicode -> 生成 `<text>` 标签。
* **特殊符号**：如果 PDF 中存在数学公式、特殊图标或乱码字体，导致 `font.toUnicode(code)` 返回空值。
  * **处理方式**：代码会触发**降级**逻辑，调用 `super.showGlyph`。
  * **结果**：这些符号会退化为 `<path>` 绘制。这保证了即使提取不出文本，视觉内容也不会丢失。

#### 4. 原生字体嵌入 (Native Font Embedding)
为了保证 `<text>` 标签在不同设备上的显示效果与 PDF 原文一致：
* **提取与转码**：从 PDF 文件流中提取嵌入的字体（`.ttf`/`.cff`），转为 Base64。
* **注入**：生成 CSS `@font-face` 规则写入 SVG 头部。
* **效果**：彻底解决了浏览器因缺字体导致的乱码或排版错乱问题。

#### 5. 图形与背景透传
为了修复早期版本中线条丢失的 Bug，采用了“放行”策略：
* **非文字指令**（如表格线 `strokePath`、背景色 `fillPath`、插图 `drawImage`）：
  * 先强制刷新当前的文字缓冲区（确保图层正确）。
  * 直接放行给父类处理，保留原汁原味的矢量绘图细节。

### 5.3 基础设施与服务层
* **坐标系适配**：自动处理 PDF（左下原点）与 SVG（左上原点）的翻转，以及页面旋转（Rotation）的宽高交换。
* **视口管理**：设置 `viewBox` 和 `preserveAspectRatio`，确保 Web 端自适应缩放。
* **增量更新 (`PdfSvgService`)**：计算新旧 SVG 的 Diff，利用缓存机制仅返回变化的页面，大幅降低前端渲染开销。

### 5.4 完整工作流总结
1.  **加载**：解析 PDF 字节流。
2.  **渲染与拦截**：
  * **文字流** -> 拦截 -> 缓冲 -> **生成 `<text>`**（可交互）。
  * **异常流**（无 Unicode） -> 降级 -> **生成 `<path>`**（保视觉）。
  * **图形流**（线/图） -> 放行 -> **生成 `<path>`/`<image>`**（保细节）。
3.  **输出**：将捕获的指令流写入 StringWriter，修补头部（ViewBox/Style），产出标准 SVG。