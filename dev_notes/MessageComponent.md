 # 消息组件 (`Message` & `MessageContainer`) 设计与实现

本文档详细阐述了 `QuickOutline` 应用中，用于显示瞬时通知的消息组件的设计与实现。该组件由 `Message.java` 和 `MessageContainer.java` 两个类协同工作，提供功能健壮、动画流畅的用户提示体验。

---

### 1. 架构设计思想

该组件的设计严格遵循“单一职责”和“高内聚，低耦合”的原则。

-   **`Message.java` (消息本身)**
    -   **职责**：一个完全自包含的UI组件，负责**自身的外观和表现**。
    -   它知道自己应该长什么样（根据 `MessageType` 显示不同样式），以及如何实现自己的“出现”（淡入）和“消失”（淡出）动画。
    -   它还封装了“自我水平居中”的逻辑，不依赖外部容器的干预。

-   **`MessageContainer.java` (消息容器)**
    -   **职责**：作为所有 `Message` 实例的**管理者和布局权威**。
    -   它负责接收外部“显示消息”的请求，动态地创建和销毁 `Message` 实例。
    -   它的核心工作是计算每个 `Message` 实例在垂直方向上应处的正确位置，并**用动画平滑地完成布局**的添加、移除和调整。

通过这种设计，我们将“一个消息长什么样”和“一堆消息如何排列”这两个关注点完美地分离开来。

### 2. `MessageContainer` 布局与动画核心

`MessageContainer` 继承自 `AnchorPane`，它通过一个核心的 `relayoutMessages()` 方法来管理所有子消息的布局。

#### 2.1. 消息的出现

调用 `showMessage()` 时，流程如下：

1.  创建一个新的 `Message` 实例。
2.  **预定位**：为了避免新消息从屏幕顶部（Y=0）飞入的突兀感，程序会检查当前容器中是否已有其他消息。如果有，则获取**最后一条消息**的Y坐标和高度，计算出新消息的“出生点”（即紧随最后一条消息的下方）。
3.  将新消息的初始 `TranslateY` 设置到这个“出生点”。
4.  将新消息添加到容器的子节点列表中。
5.  调用 `Platform.runLater(this::relayoutMessages)`，在下一个UI刷新周期中，触发一次全局重新布局。

#### 2.2. 重新布局 (`relayoutMessages`)

这是整个组件动画的核心。它被触发于**任何消息被添加或移除**之后。

1.  方法会遍历当前容器中所有的 `Message` 子节点。
2.  从一个初始的上边距（`TOP_MARGIN`）开始，依次为每个消息计算出它最终应该在的Y轴目标位置。
3.  为每个消息创建一个 `TranslateTransition`（平移动画），让它在0.5秒内，从**当前所处的位置**平滑移动到**计算出的目标位置**。
4.  这个机制保证了无论是新消息的加入，还是旧消息消失后其他消息的“补位”，整个列表的变化都是平滑、动态的，而非生硬的“瞬移”。

#### 2.3. 消息的消失

1.  `Message` 自身的 `parallelOut` 动画（一个简单的淡出效果）播放完毕后，会触发 `onFinished` 事件。
2.  `MessageContainer` 在创建 `Message` 时，就为这个 `onFinished` 事件设置了回调。回调的逻辑是：
    a.  从容器的 `getChildren()` 列表中移除这个已经看不见的 `Message` 实例。
    b.  **再次调用 `relayoutMessages()`**。
3.  `relayoutMessages()` 会重新计算剩余消息的目标位置，并创建动画让它们平滑地“下落”到新的位置，完美地填补了消失消息留下的空隙。

### 3. `Message` 自我居中机制

为了实现极致的封装，`Message` 组件自己负责水平居中，而不是依赖其容器。

-   在 `Message` 的构造函数中，设置了两个监听器：
    1.  `sceneProperty()`：监听自己何时被添加到场景（Scene）中。一旦添加，就能获取到场景的宽度，从而计算出自己的居中位置。
    2.  `widthProperty()`：监听自己的宽度何时发生变化（例如，因文本换行）。一旦变化，也会根据场景宽度重新计算居中位置。

-   通过 `setTranslateX()` 来设置水平位移，实现居中效果。

这个设计让 `Message` 成为一个“即插即用”的组件，无论将它放入哪个容器，它都能自己想办法保持水平居中。
